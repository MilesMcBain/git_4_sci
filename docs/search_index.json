[
["index.html", "Git for Scientists 1 About this", " Git for Scientists Miles McBain 1 About this This is a short course designed to get researchers up and going with git and GitHub. It acknowledges git is fundamentally a command line tool and so tries to teach the minimum command line knowledge necessary to use git effectively. Focus is on solo workflow using GitHub as a remote repository, although tools are taught that should allow the user participate in git-based collaboration without too much pain. "],
["getting-set-to-git.html", "2 Getting set to Git 2.1 Overview 2.2 Software Setup", " 2 Getting set to Git 2.1 Overview Duration: 20 min 2.1.1 Questions What tools do I need to partake in this workshop? How can I install the tools I need for my platform? 2.1.2 Objectives Get set up for learning git/GitHub and some command line. Understand how to access the command line and git. 2.2 Software Setup These setup instructions are adapted from instructions that are copyright Software Carpentry and made available for re-use by them under the CC BY 4.0 license. The task here is to get you setup with 3 main components: git - the version control software we will be studying Atom - a text editor with good integration with git/GitHub GitHub Account - access to the famed online git hosting service. 2.2.1 Git 2.2.1.1 Windows Video Tutorial The following instructions are for git for Windows 2.19.1 installer: Download the Git for Windows installer. Run the installer and follow the steps bellow: Click on “Next” to use the default install location. Click on “Next” to use the default install components. Click on “Next” to use the default Start Menu folder. Click on “Next” to use the default editor, we will change it later. Keep “Use Git from the Windows Command Prompt” selected and click on “Next”. If you forgot to do this programs that you need for the workshop will not work properly. If this happens rerun the installer and select the appropriate option. Click on “Next” to use OpenSSL library. Keep “Checkout Windows-style, commit Unix-style line endings” selected and click on “Next”. Keep “Use Windows’ default console window” selected and click on “Next”. Keep “Enable file systen caching” and “Enable Git Credential Manager” selected and click on “Next”. Do not enable experimental updates. Click on “Install”. Uncheck “View Release Notes”. Click on “Finish”. If your “HOME” environment variable is not set (or you don’t know what this is): Open command prompt (Open Start Menu then type cmd and press [Enter]) Type the following line into the command prompt window exactly as shown: setx HOME &quot;%USERPROFILE%&quot; Press [Enter], you should see SUCCESS: Specified value was saved. Quit command prompt by typing exit then pressing [Enter] This will provide you with both Git and Bash in the Git Bash program. 2.2.1.2 MacOS 2.2.1.2.1 Check you can access ‘Terminal’ The Terminal can be found in /Applications/Utilities or by searching spotlight for ‘Terminal’. You may want to keep Terminal in your dock for this workshop. 2.2.1.2.2 Git install option 1 Open the terminal and type: $ git --version If git is not installed you will get a prompt asking you if you wish to install it along with Xcode command line tools. You may be asked for your administrator password. 2.2.1.2.3 Git install option 2 Download and run the installer from: https://git-scm.com/download/mac. Hit ‘Continue’ through the prompts without modifying the installation destination or other settings. You may be asked for your administrator password. 2.2.1.3 Linux Check you have git installed by opening your terminal and running: $ git --version If git is missing install is using your package manager. E.g. by running sudo apt-get install git In the terminal. 2.2.2 Atom text editor 2.2.2.1 Windows, MacOS, Linux Open https://atom.io/ in your browser. Click the ‘Download’ button to download the Atom installer. Once Downloaded, run the installer to install Atom. 2.2.3 GitHub 2.2.3.1 Windows, MacOS, Linux Open https://github.com in your browser Click ‘Sign up for GitHub’ Enter the required personal details for step 1. Note if you use a ‘.edu’ email it will be slightly easier to get unlimited private repos for free with an educational discount. Although you can change this later. In step 2 select the free plan. In step 3 you have the option to fill out a survey or immediately hit submit. 2.2.3.1.1 Optional: Register for educational discount Open https://education.github.com/ in your browser, log in to GitHub if prompted. Click ‘Join GitHub Education’ Select the category that describes you, most likely the category that describes you, most likely ‘Researcher.’ Fill in the rest of your details, you will need to supply an .edu email, and a brief description of your planned GitHub usage. You might say “To version and share research projects.” "],
["why-gitgithub.html", "3 Why Git/GitHub 3.1 Overview 3.2 Why are we here?", " 3 Why Git/GitHub The idea here is to have a brief discussion about our motivations learning git and the benefits we anticipate. 3.1 Overview Teaching: 2 min Exercises: 5 min 3.1.1 Questions What our motivations for learning git/GitHub? What are the use cases for researchers to learn git/GitHub? 3.1.2 Objectives Understand the motivations of the group on attendance Be able to describe the various use cases for git/GitHub and identify relevant ones. Understand the difference between git and GitHub. 3.2 Why are we here? Form small groups of up to 4 with your neighbours and discuss how you expect learning git and GitHub to benefit you. "],
["command-line-basics.html", "4 Command Line Basics 4.1 Overview 4.2 Introduction 4.3 Shell, command line, cli, terminal 4.4 File system navigation 4.5 Manipulating the Filesystem 4.6 Summary", " 4 Command Line Basics In this session will introduce the command line as a general concept and learn a few commands that are complimentary to git. 4.1 Overview Teaching: 30 min Exercises: 15 min 4.1.1 Questions What is the shell, command line, or terminal? Why do I need to know the command line to use git? How do I use the command line? What commands do I need to know? 4.1.2 Objectives Understand for to form file paths and navigate directories Understand how arguments and flags are used to modify command line commands. Understand the concept of wild cards ’*’. 4.2 Introduction git is fundamentally a command line tool. Although there are many graphical user interfaces that can simplify its use, none contain the full set of features available on the command line. If you ever encounter trouble with a git repository, or need to find out how to do something important with it, you will invariably stumble across help in the form of command line instructions. This is why comfort with the command line is essential for learning git. 4.3 Shell, command line, cli, terminal All these words in the title above are used interchangeably to mean the same thing: a sparse window, usually with a dark backgroud and light text, featuring a prompt followed by a cursor. In the movies hacking computers often involves people typing really fast into this window. The command line interface (cli), is a text-based interface to a computer program. Pretty much everyone primarily uses a Graphical User Interface (GUI) to interact with their programs, but historically this is only recent. Most of the time we’ve had with computers has been using text-based interfaces and often the GUI can only access a subset of functionality available on the cli. There are many important programs that only have a cli (e.g. pandoc). ‘Terminal’ is short for ‘terminal emulator’ which is to say it is a program which emulates a physical input and display device called a terminal, that used to connect to a mainframe computer in the early days of computing. It is the program that draws the dark background, light text, and cursor. A ‘shell’ is a program that provides a cli to your operating system. Think of the functionality your operating system provides: manipulating your file system, running and stopping programs, changing system settings etc. All of this can be done via text with a shell. When you ‘open a terminal’ the program that the terminal is talking to initially is a shell. For a given operating system you often have a choice of many shells. The most popular shell is the ‘Bourne Again Shell’ or ‘bash’. 4.4 File system navigation 4.4.1 Listing files and folders We’re jumping in! Windows users, run the gitbash program now. MacOS and Linux users open a fresh terminal. First lets consider what we can see. Usually your terminal will greet you with a prompt that looks like this: miles@miles-macbook:~$ On Windows it will contain the same elements but look like this: miles@miles-pc MINGW64 ~ $ Followed by a cursor. Type the command pwd, for ‘print working directory’, and hit enter. This will show us the folder in your file system the shell is currently looking. It should return text to the terminal like so: miles@miles-macbook:~$ pwd /home/miles miles@miles-macbook:~$ The output can be interpreted like so: / -- # Root of directory structure | home -- # Home folder | miles # user&#39;s individual home folder - working directory Now here’s a new command: ls will list the contents of the working directory. Run that command and you will see the contents of your home folder. But ls is much more versatile than this. We can use things called ‘flags’ and ‘arguments’ to interface with ls’s additional features. For example we can list the contents of our Documents folder like so: miles@miles-macbook:~$ ls Documents acp_3d-1.png _cert.png parchemnt_pix2.xcf rock_opera.png the_log.txt uluru.jpg miles@miles-macbook:~$ ‘Documents’ is an argument to the ls command. We pass commands arguments by typing them after the command name. We can view hidden files using the flag -a for ‘all’. Do that for the working directory like so: miles@miles-macbook:~$ ls -a Are there more hidden files and folders than you expected? What do you notice about their file names? A flag distinct from an argument in that a flag is a constant not a variable. If a flag is present it ‘switches on’ certain behaviour. There are two forms: ‘–word’ and ‘-a’. Multiple single letter flags can be combined after a single dash. We can instruct ls to ‘list all in a long format, readable for humans’ with: miles@miles-macbook:~$ ls -alh total 428K drwxr-xr-x 36 miles miles 4.0K Oct 18 15:01 . drwxr-xr-x 3 root root 4.0K Jul 30 21:14 .. -rw------- 1 miles miles 19K Oct 18 01:29 .bash_history -rw-r--r-- 1 miles miles 220 Jul 30 21:14 .bash_logout -rw-r--r-- 1 miles miles 3.6K Oct 17 21:37 .bashrc -rw-r--r-- 1 miles miles 16K Oct 17 21:34 .bashrc.swp drwxr-xr-x 2 miles miles 4.0K Oct 16 19:49 bin drwxr-xr-x 12 miles miles 4.0K Oct 17 21:46 .cache drwxr-xr-x 4 miles miles 4.0K Aug 31 22:31 code drwx------ 23 miles miles 4.0K Oct 18 00:30 .config drwxr-xr-x 2 miles miles 4.0K Jul 30 21:16 Desktop 4.4.1.1 Combining arguments and flags In this exercise you will figure out how to use arguments and flags together. Using the flags you’ve seen so far, experiment to determine what order the flags have to be in. Create a command that lists all the contents of your ‘Documents’ folder in long format. 4.4.1.2 One flag to rule them all Most commands can give you useage information about what kinds of flags and arguments they support if you call them with the flag --help, sometimes -h will work also. Answer the following: Obtain the usage information for ls. What is a flag that you can use to arrange the output in alphabetical order? By convention flags that are full words use a double dash -- and flags are a single letter have a singe dash. Why must this be the case? 4.4.2 Moving between folders The command cd changes the working directory. To use it type cd followed by an argument which is the path of the folder to change to. The path can be either ‘absolute’ or ‘relative’. For example, assuming the current working directory is the user’s home (/home/miles), to change directory to their Downloads we could do either of these: miles@miles-macbook:~$ cd Downloads miles@miles-macbook:~/Downloads$ miles@miles-macbook:~$ cd /home/miles/Downloads miles@miles-macbook:~/Downloads$ A path that starts with / is assumed to be absolute. Paths that do not are assumed to be relative to the current working directory. Notice how the prompt has changed to reflect the new working directory. The ~ symbol is a shorthand for the user’s home directory and we can use it to form paths. 4.4.2.1 Changing Challenges You should be in your Downloads folder. Change to your Documents folder in a single command incorporating the ~ in the path. Change to the root folder of the system and list its contents. Change to your home folder. 4.4.3 Pathing shortcuts Apart from ~ there are two other symbols with special meanings in paths: . is shorthand for ‘the current working directory’. So this won’t change anywhere: miles@miles-macbook:~$ cd . and these are equivalent: miles@miles-macbook:~$ cd ./Downloads miles@miles-macbook:~$ cd Downloads .. is shorthand for ‘the parent of the current working directory’. It can be used multiple times so, cd .. would move up one folder and cd ../.. would move up two. It is useful for creating relative paths to other branches of a directory tree e.g.: miles@miles-macbook:~$ cd ~ miles@miles-macbook:~$ cd Downloads miles@miles-macbook:~/Downloads$ cd ../Documents miles@miles-macbook:~/Documents$ We moved ‘sideways’ to a folder at the same level. 4.4.3.1 Do Dot Dot Where does the following command place you on your system? How does it work? cd ~/../../.. 4.5 Manipulating the Filesystem The shell provides commands to create, move, and delete folders and files. 4.5.1 Creating Folders Let’ create an example project folder from the command line: First we’ll use the mkdir command to make a directory. The argument to the command is the path of the directory to be created. To create a directory in the current folder we just need to use its name since and the path is assumed to be relative. miles@miles-macbook:~$ mkdir eg_project Confirm the project folder exists using ls and change into it with cd: miles@miles-macbook:~$ ls miles@miles-macbook:~$ cd eg_project Then we’ll create several more folders as if the project is an analysis, mkdir can create multiple directories at once, for each argument passed. mkdir doc data results scripts 4.5.2 Moving Folders/Files Using Atom we’ll create some empty files. To open our project use File -&gt; Open Folder… and select the ‘eg_project’ folder. Create the 4 files in the eg_project folder as shown: They don’t need to contain anything. Let’s say we want to move the .Rmd file to the scripts folder. We can use the mv command to move files or folders. mv takes two arguments, the first being files or folders to move and the second being the path to move then to. Our command would look like: miles@pa00120549:~/eg_project$ mv paper.rmd scripts Let’s say we don’t like the name ‘scripts’ since ‘paper.Rmd’ is not really a script - it’s a source file. We can also use mv to rename files and folders, by moving them to a new place in the file system e.g.: miles@pa00120549:~/eg_project$ mv scripts src 4.5.2.1 Rename a file Complete the command below to rename the ‘paper.Rmd’ file to ‘methods.Rmd’ using mv: miles@pa00120549:~/eg_project$ mv src/paper.Rmd ... Be sure to check your result using ls. 4.5.3 Wildcards and Manipulations Now we’re going to see how we can use wildcards to perform actions on many files or folders at once. A wildcard is the the * symbol, and it can be used to provide file system arguments that match patterns. For example, lets say we want to list all the data files in the current folder: miles@pa00120549:~/eg_project$ ls -alh *csv This lists all files that end in ‘csv’. We could also use it a the end of a path to match all items that start with a prefix, e.g. also folders starting with ‘d’: miles@pa00120549:~/eg_project$ ls -alh d* We can use this with all types of file manipulations! 4.5.3.1 Move a group Using a single mv command, move the csv files with ‘table’ in the name to the ‘data’ folder. 4.5.4 File Removal The rm command can be used to remove files and folders. It takes the path of the files or folders as its argument. It requires the -r (recursive) flag to remove folders. To remove the ‘doc’ folder we’d do: miles@pa00120549:~/eg_project$ rm -r doc 4.5.4.1 Wildcard extermination Combine the rm command with two wildcards to remove all .csv files in our project with a single command. Hint: You can use a wildcard in the path for both the folder and file name portion. 4.6 Summary In this lesson we’ve: Demystified some of the jargon associated with the command line. Learned the anatomy of cli commands: paths, arguments, and flags. Learned about relative and absolute paths, including useful short hands (~, .., .) Seen wildcards in action. Learned a handful of shell commands. This is but a tiny fraction of what is available using the shell. The main objective here was to communicate some ideas that come in handy with git. You might like to see: http://swcarpentry.github.io/shell-novice/ for a more complete introduction.` "],
["creating-a-github-repository.html", "5 Creating a GitHub Repository 5.1 Questions 5.2 Objectives 5.3 Git vs GitHub 5.4 Creating a hosted repository on GitHub 5.5 Summary", " 5 Creating a GitHub Repository Teaching: 5 min Exercises: 5 min 5.1 Questions How can I create a git repository on GitHub for my work? How can I keep my work private if need be? How can I get a copy of the repository I can modify on my computer? 5.2 Objectives Understand options for creating a repository on GitHub. Understand how to clone a local copy repository from GitHub. 5.3 Git vs GitHub Git is called a ‘distributed version control system’. The contrast to this is a Centralised Version Constrol System (CVS) e.g. Google Docs. Git is distributed in the sense that although it can be used to syncronise changes to a repository, it does not require a ‘single source of truth’ to do that. File changes can be shared in networks of peers with any topology. Git was developed for the Linux Kernel project which has a structure reminiscent of a military. A supreme commander accepts code changes from a few trusted generals, who in turn accept code changes from a few trusted lieutenants and so on. This would not be possible with a centralised model. GitHub hosts git repositories, that act as central repositories that users synchronise with. But even this mode is more flexible than a traditional centralised approach. Users can use git locally to manage committed changes before ‘pushing’ them to GitHub. E.g. remove or amend commits. GitHub also introduces the concept of ‘forking’ whereby users can create a fork of another user’s GitHub repository, sync changes with the fork, and eventually propose changes be pulled from the fork by the original repository. Forks can themselves be forked, which allows for a complex topologies within repositories hosted on GitHub. In summary git is the program that creates repositories and powers the version control, and GitHub provides cloud hosting for git repositories with additional website features that facilitate collaboration. 5.4 Creating a hosted repository on GitHub There are a number of ways to set up a local repository that is syncronised with GitHub. In this lesson we will use the ‘GitHub first’ approach described by (Bryan, the STAT 545 TAs, and Hester 2018). At a high level the workflow for this approach looks like: Create repository on https://www.github.com Clone the GitHub repository to your PC, making a ‘local copy’. Commit changes to local copy and push to GitHub. 5.4.1 Creating a reposity on github.com The two key things we’ll need to decide when creating a repository are what the repository shall be called, and whether it shall be public or private. 5.4.1.1 On naming As suggested by GitHub, the name should be short and memorable. However, you want to balance this with searchable as your repository count grows. For example when creating repositories associated with an event or group you might include a reference to it in the name eg. ‘ABS_ML_workshop’. You get to ‘pin’ 6 repositories to your profile page ensuring they will always be easy to find. 5.4.1.2 On public vs private Public in the GitHub sense means the repository and all its history are able to be viewed (and copied) by all GitHub users. Only nominated collaborators can modify the repository. Private repositories can only be seen and interacted with by the owner and nominated collaborators. GitHub has social network type features that allow users to follow eachother and see when someone they follow creates or ‘stars’ a public repository. Starring is similar to ‘liking’ on other platforms. It is possible to take advantage of these features to get your work noticed, but this depends on your work being public. A repository’s public/private status can be changed at any time. If you are open to collaborations or feedback arising from your work you probably want to make it public as early as possible. Many people (author included) take a ‘public by default’ approach to creating repositories. This is also probably driven by the fact that users only get 1 private repository with a free tier GitHub account. 5.4.1.3 Follow some people In a minute we’ll create a repository but before that you should follow some people so you can see what the GitHub activity stream looks like. Exchange GitHub usernames with a couple of your neighbours. With each username: Type the username into the search box at the top left of the menu In the results, click the ‘Users’ link of the left of screen. Click the ‘Follow’ button associated with the username you searched for. 5.4.1.4 Create a repository Navigate to github.com and login if necessary. Click the ‘+’ icon on the top right on the menu bar and select ‘New Repository’. Choose ‘git_workshop’ as the repository name. Choose ‘Public’. Check ‘Initialize this repository with a README’ &lt;– IMPORTANT Click ‘Create repository’ 5.4.1.5 On the README It is good practice for every repository to have a README.md file. GitHub will use this file as the ‘front page’ of the respository, so it is the place to communicate what your work is about. Even in private repositories you’ll want to put some notes here that will help future you remember what the project was or where it was up to. It is especially important to initialise the repository with a README in this workflow as this will allow you to clone the repository to a local copy immediately. Empty repositories cannot be cloned. 5.5 Summary Creating a repository using the GitHub GUI private vs public naming README References "],
["using-a-git-repository.html", "6 Using a git repository 6.1 Questions 6.2 Objectives 6.3 Local git configuration 6.4 Anatomy of git cli commands 6.5 Cloning a repository 6.6 Local repository workflow 6.7 Status - determining when things have changed 6.8 Diff - seeing what’s changed 6.9 Add - moving changes to staging 6.10 Reset - unstaging changes 6.11 Commit - recording staged changes 6.12 Push - sending commits to GitHub 6.13 Summary", " 6 Using a git repository Teaching: 40 min Exercises: 20 min 6.1 Questions How do I get a local copy of my repository? How do I record changes to my files using git? How do I view the status of the repository? How do I syncronise the history with GitHub? 6.2 Objectives Understand the PC configuration required to use a git repository Understand how to create a local copy of a GitHub repository. Understand the conceptual areas: working tree, staging area Understand the basic update workflow: add to staging, commit with message, push to origin 6.3 Local git configuration Before we can use git we need to give it some personal information. Every committed change to a repository requires the author’s name and email as metadata. We register this information using the git cli. 6.3.1 Configure your git user information Open your terminal, or gitbash or Windows. Use these commands to register your name and email address, making sure it’s the same email address you registered with GitHub: $ git config --global user.email your.email@example.com $ git config --global user.name &quot;Firstname Lastname&quot; You can check the value of this configuration by running the same command with no value argument: e.g. $ git config --global user.email 6.3.2 Configure your text editor The text editor you configure here is the one git will open so you can write messages that explain your changes. Ideally it is an editor that opens really fast or one you always have open. 6.3.2.1 Set up Atom The default editor, Vim, is often found to be difficult to use by beginners and is the subject of numerous memes. In this course we will use Atom, which we will have open most of the time. You can change this at a later stage. Configure it like so: $ git config --global core.editor &quot;atom --wait&quot; A list of configurations for other popular editors can be found here. 6.4 Anatomy of git cli commands All git commands we will learn share elements with those you have just seen. They will all begin with git followed immediately by an argument that defines the type of command you would like git to perform. In the above example the command is config. Flags, both - and -- types are used to alter the way the command is performed. Finally there are additional arguments that are required to perform the command. In the example above the first argument is the configuration key, and the second argument is the value it should take. The --global flag makes the configuration global, so it will apply to all repositories. Without --global the configuration applies to only the repository in the current working directory (In our case there is no such repository). In summary, the form is: $ git &lt;command&gt; &lt;command flags&gt; &lt;command arguments&gt; 6.4.1 How to git help Like other cli programs we’ve seen we can get help with --help. This can be done in the context of git the program or a single command i.e.: $ git --help $ git config --help Help for a specific command will open up a help browser in the terminal, you can scroll with the arrow keys or by paging, and quit with ‘q’. 6.5 Cloning a repository Cloning is the process of creating a local copy of a remote repository, like one hosted on GitHub. Before we clone a repository, think about where you will clone it to. You might like to create yourself a repos folder in your home folder. To clone a repository use the clone command followed by 2 arguments: $ git clone &lt;repository URL&gt; &lt;parent folder&gt; The parent folder is the folder that will contain your repository contents. The folder must be empty or the command will abort. If you leave the parent folder blank, the default behaviour is to create a folder for the repository in the current working directory with the same name as the repository. This is helpful and common usage. 6.5.1 Create a repos folder (optional) Use the mkdir command to create a folder called ‘repos’ in your home folder (~) 6.5.2 Clone your repository In your browser: navigate to your ‘git_workshop’ repository on GitHub Click the green ‘Clone or Download’ button on the right of screen. Use the clipboard icon to copy your repository’s URL. In your terminal: Change to the folder that will house your repositories with cd. Use this command to clone your repository, with your URL pasted in for ‘’: $ git clone &lt;URL&gt; Enter your GitHub password when prompted and press enter. Here is some sample output: miles@miles-macbook:~/repos$ git clone https://www.github.com/milesmcbain/git_workshop.git Cloning into &#39;git_workshop&#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. 6.5.3 What makes a git repository? If you cd into your repository folder and run the ls -a command you will see a hidden folder called ‘.git’. Have a look at its contents if you like. This is where git stores all the metadata it needs to operate your repository, including the complete history of every file ever added. Be careful not to delete or rename the ‘.git’ folder or your repository will no longer work with git. 6.6 Local repository workflow At a high level the workflow for your repository is: Create, update, or delete local files. Move changes to the staging area. Commit changes in the staging area to the repository history. Push commits to the upstream remote. There’s a bit of specific terminology here we can break down: You make changes to files in the repository as you normally would with any file on your computer. Those changes are saved on your computer but they are not recorded in your repository until they are committed. A commit is a record of related (usually) changes with associated metadata about like author, time, date, and reason for change. A commit is not a snapshot. It is a delta. Only what changed is recorded. Therefore a single commit is not enough to recover a repository. You need all commits in order. You can think of a repository as a timeline of commits. This timeline is commonly referred to as the history. The staging area is a conceptual area where you can place changes you plan to commit imminently. You might have made many changes for varying reasons, so it makes sense to group them into commits related to the reason. You place files to be committed together in the staging area which feeds into your next commit. As you make commits, your local repository moves ahead of the remote repository (GitHub). You push your new commits to the remote to bring its history up to the present state of your local repository. 6.7 Status - determining when things have changed The status command gives us useful information about the status of our work relative to the local repository history and remote repository. It can be run with no additional arguments or flags. It will search upward from the current working directory until it finds a git repository or fails. If we run it from within our freshly cloned repository we get: $ git status On branch master Your branch is up-to-date with &#39;origin/master&#39;. nothing to commit, working tree clean Which tells us: our local branch our repository status with respect to our remote branch history if we have uncommitted changes in the repository file structure (the working tree). 6.7.1 Aside: branches You can think of branches as parallel timelines in your repository history. Branches become necessary as the size of the team and project grows. For this lesson all you need to know is that when you create and clone a repository from GitHub its history contains only one timeline: a branch called master. 6.7.2 Introducing changes Now we’ll introduce some changes and see how the status changes. Let’s do the following: Create a new folder called ‘data’ in our repository with mkdir Create a new file in the repository called ‘analysis.Rmd’ with Atom Create a new file in the repository called ‘data.csv’ with Atom. Add the following text on a new line in README.md: “Just gitting started!” This is what Atom should look like when we’re done: Running git status again should produce different output along the lines of: $ git status On branch master Your branch is up-to-date with &#39;origin/master&#39;. Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: README.md Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) analysis.Rmd data.csv no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Some things of note: Our master branch is still up-to-date with the remote repository branch ‘origin/maser’ - no commits have been made. git is suggesting commands we could use from here: add, checkout, and commit. git has detected README.md was modified. git has detected a new untracked files: analysis.Rmd, data.csv. git has not detected our new folder: ‘data’. Git tracks changes to files only. 6.8 Diff - seeing what’s changed We can ask git to show us exactly what has changed in any file or all files using the git diff command. It will compare differences in files with the last committed versions. Colour coded output describing differences appears in the terminal. The syntax is: git diff &lt;path&gt; &lt;flags&gt; If &lt;path&gt; is omitted all files are ‘diffed’ (this is the lingo). A useful flag is --colour-words which will show individual word changes in context, rather than changed lines (the default). To diff README.md we would do: git diff README.md 6.9 Add - moving changes to staging The add command moves changed files to the staging area in preparation for a commit. The syntax is: $ git add &lt;pathspec&gt; Where the &lt;pathspec&gt; argument is a path to file or folder. In the case of a folder, all files in the folder will be added to staging. Paths can be formed using wildcards, *, and short-hands e.g. . - This comes in quite handy for staging groups of files. add can be used to add stage an existing (tracked) file the repository knows about or an entirely new file (untracked) like ‘analysis.Rmd’ in the previous section. The syntax is the same. 6.9.1 Stage all files in a single command Using a single git add command to stage ‘analysis.Rmd’, ‘README.md’, and ‘data.csv’. Hint: git add --help might have something useful to say regarding the &lt;pathspec&gt; argument. 6.9.2 Types of files to stage There are some considerations when staging files: Once a file is committed it is hard to remove from the history. Beware committing sensitive information like security tokens. Git works best with files that are ‘human readable’, i.e. source files. binary files or media files cannot be ‘diffed’ to work out delta. GitHub has individual file size limit of 100 MB 6.10 Reset - unstaging changes Git reset is a powerful command that is used in the context of undoing things we have done locally before pushing. It can reset the staging area and also reset where we are on our history timeline to a point in the past, allowing history to be rewritten. Time travelling and changing history is generally a bad idea and in the worst case can lead to a time paradox, the result of which could cause a chain reaction that would unravel the very fabric of the space-time continuum and destroy the entire universe! We will just consider the basic usage for resetting staging in this section. The syntax is: $ git reset &lt;path&gt; Beware committing sensitive information like security tokens. To unstage files or folders on the path specified by the &lt;path&gt; argument. Unstaging everything at once is also an option by omitting &lt;path&gt;: $ git reset 6.10.1 Born for the stage We made a mistake and should move ‘data.csv’ to the data folder! Unstage ‘data.csv’ with git reset Move ‘data.csv’ to the ‘data’ folder with mv add ‘data.csv’ to staging in its new location. 6.10.2 Caution: –hard It is likely in your travels with git that you will be at some stage advised to do git reset --hard to resolve a problem. The --hard flag will result in all changes being unstaged and additionally all tracked files being reset to their last committed state. Clearly there is a risk of work loss. Make sure you don’t want to keep anything before you do this! 6.11 Commit - recording staged changes Git commit is how you record staged changes in your history. The main activity involved in making a commit is writing the commit message which explains the changes. The basic syntax is simple: $ git commit Like add you can run this with your working directory set to any child folder of a git repository. The command will trigger a new window to open in Atom with this text: # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # On branch master # Your branch is up-to-date with &#39;origin/master&#39;. # # Changes to be committed: # modified: README.md # new file: analysis.Rmd # new file: data/data.csv # 6.11.1 Aborting a commit The information provided summarises the current branch and the changes to be committed. This is a good opportunity to sanity check this information before making history. If you spot something fishy, close the file without adding a message and the commit will be aborted. 6.11.2 Completing a commit To complete the commit you must: Write short informative commit message on the first line e.g. “added analysis source and dataset” You can continue with detailed info on line 3 - line n as needed. some good guidelines are here Save the file Close the file After you close the file git will return some output to your terminal: $ git commit [master c6766f1] added analysis source and dataset 3 files changed, 2 insertions(+), 1 deletion(-) create mode 100644 analysis.Rmd create mode 100644 data/data.csv [master c6766f1] tells us a commit with a hash matching c6766f1 was added to our master branch. Your hash will be different as they are intended to uniquely identify the commit. The hashes come in useful when we need to recover past versions. 6.11.3 Common usage: git commit -m “message” It is possible to complete a commit without editing a file in a text editor. The -m flag can be followed with a quoted string which will be used as the commit message, like: $ git commit -m &quot;a short commit message&quot; There are two drawbacks with this approach: You do not get the final opportunity to see what is staged and what branch you are on which can be helpful in avoiding mistakes. You are discouraged from writing detailed commit messages since typing into the terminal on a single line is cumbersome. It can be faster though so it might be great for your pattern of use. 6.11.4 Post commit status Finally let’s check the status of the repository: $ git status On branch master Your branch is ahead of &#39;origin/master&#39; by 1 commit. (use &quot;git push&quot; to publish your local commits) nothing to commit, working tree clean As we add commits to our local repository it moves ahead of the remote repository. Git is suggesting that we probably want to push our commits to GitHub (‘origin/master’), and indeed that is the next step. 6.12 Push - sending commits to GitHub Most common usage of the push command is: $ git push With a working directory that is a child of a git repository. This will cause all our new local commits to be sent to all configured remote repositories. In the case of our repository, it came configured with a single remote, GitHub, when we cloned it. As we have discussed, git supports complex decentralised topologies including having multiple remotes. As an example it would be possible to push our commits to remote repositories hosted on GitHub and GitLab simultaneously. The push command has flags and arguments that support these kinds of scenarios but you will likely never use them. If we push our current commit we see: $ git push Counting objects: 5, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (5/5), 419 bytes | 0 bytes/s, done. Total 5 (delta 0), reused 0 (delta 0) To https://www.github.com/milesmcbain/git_workshop.git fef3706..ead4b25 master -&gt; master Note*: You will be asked for your GitHub username as password at this point. MacOS and Linux users, type them into the terminal prompts. Windows users, a popup will appear - Enter your details and click ‘Login’ 6.12.1 GitHub history In your browser, navigate to your repository on GitHub. You can go straight to https://www.github.com/YOURUSER/git_workshop, replacing YOURUSER appropriately. On your repository page, in the upper left of screen there is a circular arrow clock icon with a ‘commits’ label. Click it to see your repository history. In the history view, click the commit hash on the right of screen to see the delta for that commit 6.12.2 Your turn: renaming a file In your ‘git_workshop’ repository Rename ‘analysis.Rmd’ to ‘00_analysis.Rmd’. Run git status. Stage all the changes. Commit the changes with an informative message. Push the changes to GitHub and verify the remote repository looks as you expect. Was this tricky? Discuss with your neighbours what made it complicated. 6.13 Summary You learned the git commands to support a solo workflow: git clone git config –global user.name, user.email, core.editor git status git add, git add * git reset (to remove files from staging) git commit, commit -m git push "],
["distributed-workflow.html", "7 Distributed Workflow 7.1 Questions 7.2 Objectives 7.3 You: your most annoying collaborator 7.4 Simplest case: Pulling commits pushed from elsewhere 7.5 Resolving a merge conflict 7.6 Using merge tools 7.7 Summary", " 7 Distributed Workflow Teaching: 35 min Exercises: 10 min 7.1 Questions How do I bring down commits I pushed to GitHub at work to my home PC, or vice versa? What happens when files on GitHub conflict with what I have committed locally? 7.2 Objectives Understand how to pull down commits pushed on another computer to my local copy. Understand what a merge conflict is and how to resolve it using information provided by git. 7.3 You: your most annoying collaborator An advantage of syncing with the cloud (GitHub) is that you can clone your repository onto multiple computers and use the remote repository to keep all the local copies in sync. This workflow requires one new commands and some understanding of what can go wrong. 7.3.1 Simulate another computer We can simulate another computer in the mix by creating a second local copy of your repository on your current computer. 7.3.1.1 Clone a second local copy In your browser, get the url for your repository. In you terminal, use the git clone command to clone your repository to a new folder with the name ‘other_git_workshop’ The form of the command will be git clone &lt;URL&gt; &lt;Path to folder&gt; Use ls to check everything looks correct. Note: You didn’t clone one repository inside the other DID you? Use mv to fix. 7.3.1.2 Outcome To be clear you should now have 2 local copies: ‘git_workshop’ - the one we initially cloned in a previous lesson. ‘other_git_workshop’ - the one we just cloned, simulating a copy on a second computer. Both of these reference the same GitHub repository. 7.4 Simplest case: Pulling commits pushed from elsewhere We use the git pull command to pull commits from the remote repository to a local copy. The most common usage is without any additional arguments or flags. Similarly to push, they exist but it is likely you will never use them. To see how push works we have to commit and push some changes in other_git_workshop. Do this: In your terminal, call git clone wit your username for YOURUSER: $ git clone http://www.github.com/YOURUSER/git_workshop other_git_workshop Change into the ‘other_git_workshop’ folder with cd In Atom, add a line to ‘00_analysis.Rmd’ that says ‘We got data.’ In your terminal, stage the change to ‘00_analysis.Rmd’ with git add Commit the change to ‘00_analysis.Rmd’ with git commit using an informative commit message. Push your commit with git push 7.4.1 Refreshing repository status Now let’s see what the status of the ‘git_workshop’ repository is: Change into the git_workshop folder with cd Call git status The output will look like this: On branch master Your branch is up-to-date with &#39;origin/master&#39;. nothing to commit, working tree clean WAT? We just pushed commits to the remote repository but status is saying we’re up to date? It turns out that status is considers whether we are up to date with the last known version of the repository history, which we got when we pushed last. status does not contact the remote to see if anything new has changed. We can explicitly contact the repository with a command called fetch: $ git fetch remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From https://www.github.com/milesmcbain/git_workshop 3ff91b0..ef6c217 master -&gt; origin/master Now if we call git status we should see: $ git status On branch master Your branch is behind &#39;origin/master&#39; by 1 commit, and can be fast-forwarded. (use &quot;git pull&quot; to update your local branch) nothing to commit, working tree clean We see now we are behind the remote by 1 commit. Apparently we can be fast-forwarded. A fast-forward means our branch can have the new commits from the remote repository merged into its history by just inserting them after the old history. It’s git’s way of telling us there’s no problems it needs a human to sort out. 7.4.2 Pulling We do not need to fetch before we run the pull command. If we run the pull command and no new work exists it nothing will happen. If we run the git pull command we will get the work that was comitted and pushed in other_git_workshop: $ git pull Updating 3ff91b0..ef6c217 Fast-forward 00_analysis.Rmd | 1 + 1 file changed, 1 insertion(+) 7.4.3 Happy Pull Workflow We can avoid issues if we always run the pull command as our first action when doing work. If we are working without collaborators, there can never be a conflict between the local copy and the remote, because we always build on the latest work committed to the remote and pulled to our local copy. The two things you can do to create problems are: forgetting to pull and making commits forgetting to push so when you do remember to pull next you get no new work. Forgetting is inevitable, don’t be too hard on yourself if it happens and don’t panic. Git was built with conflict resolution in mind. The situation can be resolved and you won’t lose work. 7.5 Resolving a merge conflict We will simulate a situation where you forgot to pull existing remote commits, and made new commits locally. 7.5.1 Adding remote commits Change into the ‘other_git_workshop’ folder with cd In Atom, Change the first line in ‘00_analysis.Rmd’ to say ‘We got interesting data.’ In your terminal, stage the change to ‘00_analysis.Rmd’ with git add Commit the change to ‘00_analysis.Rmd’ with git commit using an informative commit message. Push your commit with git push The push should succeed. 7.5.2 Add local commits Change into the ‘git_workshop’ folder with cd In Atom, Change the first line in ‘00_analysis.Rmd’ to say ‘We got exciting data.’ In your terminal, stage the change to ‘00_analysis.Rmd’ with git add Commit the change to ‘00_analysis.Rmd’ with git commit using an informative commit message. Push your commit with git push The push fails with: $ git push To http://www.github.com/milesmcbain/git_workshop ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to &#39;http://www.github.com/milesmcbain/git_workshop&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. So we take git’s hint and call git pull which says: $ git pull remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From http://www.github.com/milesmcbain/git_workshop ef6c217..923cb03 master -&gt; origin/master Auto-merging 00_analysis.Rmd CONFLICT (content): Merge conflict in 00_analysis.Rmd Automatic merge failed; fix conflicts and then commit the result. CONFLICT(!). Git tells us the file with the problem. This happened because both changes affected the same line. Git is asking us to ‘fix merge conflicts and commit the result’. 7.5.3 Fixing merge conflicts When a merge conflict happens git will place some markup inside the file to assist with resolving a conflict. Atom will see this and create a dialogue. If we check the contents of ‘git_workshop/00_analysis.Rmd’ in Atom we should see: We resolve the conflict by clicking ‘Use me’ on the one we want to keep. In this case let’s choose the pink ‘our changes’. Now: Save the file in Atom. In the terminal, stage the file with git add. Commit the file with git commit Notice how git has automatically added information to the commit message: Merge branch &#39;master&#39; of https://www.github.com/milesmcbain/git_workshop # Conflicts: # 00_analysis.Rmd # # It looks like you may be committing a merge. # If this is not correct, please remove the file # .git/MERGE_HEAD # and try again. # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # On branch master Leave the message unchanged, save and close the file to complete the commit. This type of commit is called a ‘merge commit’. Now all that is left: push the merge commit with git push. change to the other_git_workshop folder and pull the merge commit with git pull The pull will succeed and the repositories are now both in sync with GitHub. Check this if you like. 7.5.4 Merging without Atom fanciness You can get rid off the merge assistance in Atom by right clicking on the conflict and selecting ‘dismiss’. In plain text the conflict markup looks like this: &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD We got exciting data. ======= We got interesting data. &gt;&gt;&gt;&gt;&gt;&gt;&gt; 3f6079ade2cf03e0f4c5c5bd7bec5101100cb51a To understand this you need one new piece of information: HEAD is a reference which refers to the last commit on the current local branch, so HEAD is the last thing we committed to master. The other really long ugly string is the full hash of the commit on the remote. So to resolve the conflict in plain text, we delete the fencing and replace the section with the text that we wish to use. Importantly, the text can: Use either version Use both versions Use neither version and contain completely new content. For example a valid way to resolve this conflict would be: We got exciting data, We got interesting data. We’d save, stage and commit that and git would accept it as resolving the conflict. 7.5.4.1 Manual Merge In the same fashion as our example engineer a conflict by changing the same line in: ‘other_git_workshop/00_analysis.Rmd’ ‘git_workshop/00_analysis.Rmd’ Commit and push one before committing and pushing the other. This time resolve the conflicted file in plain text by dismissing the atom merge help (right click ‘dismiss’). 7.6 Using merge tools Many git GUI applications have powerful features for resolving merge conflicts quickly and painlessly. At the time of writing some of the best are: GitKraken Sublime Merge Meld 7.7 Summary You learned key tools for working in a distributed way by yourself git pull resolving merge conflicts "],
["getting-out-of-trouble.html", "8 Getting out of trouble 8.1 Questions 8.2 Objectives 8.3 Helping yourself with git 8.4 Fixing a previous commit 8.5 Restoring a file to an earlier version 8.6 Restoring the entire repository to an earlier version 8.7 When all else fails 8.8 Summary", " 8 Getting out of trouble Teaching: 15 min Exercises: 10 min 8.1 Questions I messed up the commit message or files committed, how can I edit a commit? I realised I introduced a problem, how can I revert a file to an earlier version? Something is not right, how can I restore an earlier version of the whole repository? 8.2 Objectives Understand how to solve some common problems in arising in git. 8.3 Helping yourself with git In this lesson we’ll cover just a few of the ways you can get yourself out of trouble with git. The key new you commands we’ll discuss are: checkout which will allow us to restore files to previous versions. There are other great resources on this topic, see: * OhShitGit * Getting Unstuck from Git 8.4 Fixing a previous commit In this scenario you’ve made a commit and then you realise you missed a file or made an error with the commit message. You an call the git commit command with the --ammend flag and any staged files will be added to the previous commit and you will be given a chance to rewrite the commit message. 8.4.1 Your first amendment Using the ‘git_workshop’ repository from previous lessons: Open 00_analysis.Rmd in Atom and insert a new line: “part one” On the terminal, Save, stage, and commit the file with commit messge “added part one” In Atom, add a new line in 00_analysis.Rmd: “part two” Save and stage the file. Ammend the commit as described above. Push the commit. Check the history on GitHub and confirm “part one” and “part two” were added as part of the same commit. 8.5 Restoring a file to an earlier version Let’s say you’ve identified a problem with a specific file and would like to restore it to an earlier version. You have two options: You can look through the history, say on GitHub, and find the hash of a commit from when things were fine. You restore the file to the version it was when that commit was made. You can’t find a commit or oh god please there’s not much time. You can restore the file to the version it was some time ago After you have restored the file, you can stage, commit, and push it to make it the current version. 8.5.1 Restoring to a hash You don’t need the complete hash, just enough letters to ensure a unique match. 6 or so will usually do. The format of the command is $ git checkout &lt;patial hash&gt; &lt;file path&gt; The hashes in your repository are unique so I can’t give an example that will work for you. But this would restore 00_analysis.Rmd to its a blank state in my repository: $ git checkout 3ff91b 00_analysis.Rmd 8.5.2 Restoring to a time period ago Let’s say it’s Monday morning and you realise you made some bad changes to a file on Friday afternoon, but you’re not sure when, and you just need to fix it in a hurry before your meeting with your supervisor. You could do: $ git checkout &quot;@{3 days ago}&quot; &lt;file path&gt; To restore the file to as it was on Friday morning. You can use decimal numbers and any time unit. @{20 minutes ago} might be good for those last minute presentation ‘tweaks’. 8.5.3 Restoring to most recent version If you decide you would like to return a file you restored with checkout to it’s most recent version, remember that HEAD is a reference to the latest commit. So you can again use checkout: $ git checkout HEAD &lt;file path&gt; 8.5.4 Restoration resuce Using the ‘git_workshop’ repository: Using git checkout, Restore ‘analysis.Rmd’ to the working directory. This is what ‘00_analysis.Rmd’ was called before we changed its name. 8.6 Restoring the entire repository to an earlier version You have a few options here depending on the outcome you want. Here I assume you want to temporarily roll back to check an analysis result with an old version, but you do not want to permanently reset the repository and its history to an earlier time point. If you call git checkout with no &lt;file path&gt; argument the entire repository will be rolled back to the commit hash or time you specified. For example: git checkout &quot;@{1 day ago}&quot; However be warned if you make commits in this state, they will work but they will not be added to the history - You can’t just insert stuff into the middle of history(!). You can add these orphan commits to a branch, but this is beyond the scope of this lesson. This state of git purgatory is called ‘detached HEAD’ as the head reference no longer points to a commit on the branch’s timeline. As before, you can return the entire repository to the present with: git checkout HEAD Permanently resetting the repository and its history to an earlier time point is possible but can lead to permanent loss of work. You will need to look into advanced usage of git reset --hard. 8.7 When all else fails This is also called ‘burning it down’. 8.8 Summary You learned git commands that are useful for updating commits, restoring files, and jumping back to previous repository versions. git commit –amend git checkout 123abc file.ext git checkout 123abc git checkout “@{4 days ago}” "],
["learning-more.html", "9 Learning More", " 9 Learning More The objective of this workshop/course was to get you comfortable enough with the command line and git to start using it immediately for your own solo projects. If you want to learn about using GitHub collaboratively, you might like to check out: This paper about how scientists can collaborate using git, which itself was written collaboratively using git on GitHub: https://github.com/karthik/smb_git This chapter of Hadley Wickham’s book on making R packages: http://r-pkgs.had.co.nz/git.html this paper which gives a quick introduction on git for scientists: https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004668 "],
["references.html", "10 References", " 10 References "]
]
